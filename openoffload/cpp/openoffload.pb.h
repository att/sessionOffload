// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: openoffload.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_openoffload_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_openoffload_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_openoffload_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_openoffload_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_openoffload_2eproto;
namespace openoffload {
namespace v1alpha2 {
class Empty;
class EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class actionType;
class actionTypeDefaultTypeInternal;
extern actionTypeDefaultTypeInternal _actionType_default_instance_;
class activationStatus;
class activationStatusDefaultTypeInternal;
extern activationStatusDefaultTypeInternal _activationStatus_default_instance_;
class addSessionResponse;
class addSessionResponseDefaultTypeInternal;
extern addSessionResponseDefaultTypeInternal _addSessionResponse_default_instance_;
class deviceDescription;
class deviceDescriptionDefaultTypeInternal;
extern deviceDescriptionDefaultTypeInternal _deviceDescription_default_instance_;
class deviceList;
class deviceListDefaultTypeInternal;
extern deviceListDefaultTypeInternal _deviceList_default_instance_;
class registrationStatus;
class registrationStatusDefaultTypeInternal;
extern registrationStatusDefaultTypeInternal _registrationStatus_default_instance_;
class sessionId;
class sessionIdDefaultTypeInternal;
extern sessionIdDefaultTypeInternal _sessionId_default_instance_;
class sessionRequest;
class sessionRequestDefaultTypeInternal;
extern sessionRequestDefaultTypeInternal _sessionRequest_default_instance_;
class sessionResponse;
class sessionResponseDefaultTypeInternal;
extern sessionResponseDefaultTypeInternal _sessionResponse_default_instance_;
class statisticsRequestArgs;
class statisticsRequestArgsDefaultTypeInternal;
extern statisticsRequestArgsDefaultTypeInternal _statisticsRequestArgs_default_instance_;
}  // namespace v1alpha2
}  // namespace openoffload
PROTOBUF_NAMESPACE_OPEN
template<> ::openoffload::v1alpha2::Empty* Arena::CreateMaybeMessage<::openoffload::v1alpha2::Empty>(Arena*);
template<> ::openoffload::v1alpha2::actionType* Arena::CreateMaybeMessage<::openoffload::v1alpha2::actionType>(Arena*);
template<> ::openoffload::v1alpha2::activationStatus* Arena::CreateMaybeMessage<::openoffload::v1alpha2::activationStatus>(Arena*);
template<> ::openoffload::v1alpha2::addSessionResponse* Arena::CreateMaybeMessage<::openoffload::v1alpha2::addSessionResponse>(Arena*);
template<> ::openoffload::v1alpha2::deviceDescription* Arena::CreateMaybeMessage<::openoffload::v1alpha2::deviceDescription>(Arena*);
template<> ::openoffload::v1alpha2::deviceList* Arena::CreateMaybeMessage<::openoffload::v1alpha2::deviceList>(Arena*);
template<> ::openoffload::v1alpha2::registrationStatus* Arena::CreateMaybeMessage<::openoffload::v1alpha2::registrationStatus>(Arena*);
template<> ::openoffload::v1alpha2::sessionId* Arena::CreateMaybeMessage<::openoffload::v1alpha2::sessionId>(Arena*);
template<> ::openoffload::v1alpha2::sessionRequest* Arena::CreateMaybeMessage<::openoffload::v1alpha2::sessionRequest>(Arena*);
template<> ::openoffload::v1alpha2::sessionResponse* Arena::CreateMaybeMessage<::openoffload::v1alpha2::sessionResponse>(Arena*);
template<> ::openoffload::v1alpha2::statisticsRequestArgs* Arena::CreateMaybeMessage<::openoffload::v1alpha2::statisticsRequestArgs>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace openoffload {
namespace v1alpha2 {

enum IP_VERSION : int {
  _IPV4 = 0,
  _IPV6 = 1,
  IP_VERSION_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  IP_VERSION_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool IP_VERSION_IsValid(int value);
constexpr IP_VERSION IP_VERSION_MIN = _IPV4;
constexpr IP_VERSION IP_VERSION_MAX = _IPV6;
constexpr int IP_VERSION_ARRAYSIZE = IP_VERSION_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IP_VERSION_descriptor();
template<typename T>
inline const std::string& IP_VERSION_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IP_VERSION>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IP_VERSION_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    IP_VERSION_descriptor(), enum_t_value);
}
inline bool IP_VERSION_Parse(
    const std::string& name, IP_VERSION* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IP_VERSION>(
    IP_VERSION_descriptor(), name, value);
}
enum PROTOCOL_ID : int {
  _HOPOPT = 0,
  _TCP = 6,
  _UDP = 17,
  PROTOCOL_ID_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PROTOCOL_ID_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PROTOCOL_ID_IsValid(int value);
constexpr PROTOCOL_ID PROTOCOL_ID_MIN = _HOPOPT;
constexpr PROTOCOL_ID PROTOCOL_ID_MAX = _UDP;
constexpr int PROTOCOL_ID_ARRAYSIZE = PROTOCOL_ID_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PROTOCOL_ID_descriptor();
template<typename T>
inline const std::string& PROTOCOL_ID_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PROTOCOL_ID>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PROTOCOL_ID_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PROTOCOL_ID_descriptor(), enum_t_value);
}
inline bool PROTOCOL_ID_Parse(
    const std::string& name, PROTOCOL_ID* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PROTOCOL_ID>(
    PROTOCOL_ID_descriptor(), name, value);
}
enum SESSION_STATE : int {
  _ESTABLISHED = 0,
  _CLOSING_1 = 1,
  _CLOSING_2 = 2,
  _CLOSED = 3,
  SESSION_STATE_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SESSION_STATE_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SESSION_STATE_IsValid(int value);
constexpr SESSION_STATE SESSION_STATE_MIN = _ESTABLISHED;
constexpr SESSION_STATE SESSION_STATE_MAX = _CLOSED;
constexpr int SESSION_STATE_ARRAYSIZE = SESSION_STATE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SESSION_STATE_descriptor();
template<typename T>
inline const std::string& SESSION_STATE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SESSION_STATE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SESSION_STATE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SESSION_STATE_descriptor(), enum_t_value);
}
inline bool SESSION_STATE_Parse(
    const std::string& name, SESSION_STATE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SESSION_STATE>(
    SESSION_STATE_descriptor(), name, value);
}
enum SESSION_CLOSE_CODE : int {
  _NOT_CLOSED = 0,
  _FINACK = 1,
  _RST = 2,
  _TIMEOUT = 3,
  SESSION_CLOSE_CODE_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SESSION_CLOSE_CODE_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SESSION_CLOSE_CODE_IsValid(int value);
constexpr SESSION_CLOSE_CODE SESSION_CLOSE_CODE_MIN = _NOT_CLOSED;
constexpr SESSION_CLOSE_CODE SESSION_CLOSE_CODE_MAX = _TIMEOUT;
constexpr int SESSION_CLOSE_CODE_ARRAYSIZE = SESSION_CLOSE_CODE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SESSION_CLOSE_CODE_descriptor();
template<typename T>
inline const std::string& SESSION_CLOSE_CODE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SESSION_CLOSE_CODE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SESSION_CLOSE_CODE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SESSION_CLOSE_CODE_descriptor(), enum_t_value);
}
inline bool SESSION_CLOSE_CODE_Parse(
    const std::string& name, SESSION_CLOSE_CODE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SESSION_CLOSE_CODE>(
    SESSION_CLOSE_CODE_descriptor(), name, value);
}
enum REQUEST_STATUS : int {
  _ACCEPTED = 0,
  _REJECTED = 1,
  _REJECTED_SESSION_NONEXISTENT = 2,
  _REJECTED_SESSION_TABLE_FULL = 3,
  _REJECTED_SESSION_ALREADY_EXISTS = 4,
  REQUEST_STATUS_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  REQUEST_STATUS_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool REQUEST_STATUS_IsValid(int value);
constexpr REQUEST_STATUS REQUEST_STATUS_MIN = _ACCEPTED;
constexpr REQUEST_STATUS REQUEST_STATUS_MAX = _REJECTED_SESSION_ALREADY_EXISTS;
constexpr int REQUEST_STATUS_ARRAYSIZE = REQUEST_STATUS_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* REQUEST_STATUS_descriptor();
template<typename T>
inline const std::string& REQUEST_STATUS_Name(T enum_t_value) {
  static_assert(::std::is_same<T, REQUEST_STATUS>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function REQUEST_STATUS_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    REQUEST_STATUS_descriptor(), enum_t_value);
}
inline bool REQUEST_STATUS_Parse(
    const std::string& name, REQUEST_STATUS* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<REQUEST_STATUS>(
    REQUEST_STATUS_descriptor(), name, value);
}
enum ACTION_TYPE : int {
  _DROP = 0,
  _FORWARD = 1,
  _MIRROR = 2,
  _SNOOP = 3,
  ACTION_TYPE_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ACTION_TYPE_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ACTION_TYPE_IsValid(int value);
constexpr ACTION_TYPE ACTION_TYPE_MIN = _DROP;
constexpr ACTION_TYPE ACTION_TYPE_MAX = _SNOOP;
constexpr int ACTION_TYPE_ARRAYSIZE = ACTION_TYPE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ACTION_TYPE_descriptor();
template<typename T>
inline const std::string& ACTION_TYPE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ACTION_TYPE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ACTION_TYPE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ACTION_TYPE_descriptor(), enum_t_value);
}
inline bool ACTION_TYPE_Parse(
    const std::string& name, ACTION_TYPE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ACTION_TYPE>(
    ACTION_TYPE_descriptor(), name, value);
}
enum INTERFACE_TYPE : int {
  _NONE = 0,
  _SOFTWARE = 1,
  _SMARTNIC = 2,
  _NOS = 3,
  INTERFACE_TYPE_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  INTERFACE_TYPE_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool INTERFACE_TYPE_IsValid(int value);
constexpr INTERFACE_TYPE INTERFACE_TYPE_MIN = _NONE;
constexpr INTERFACE_TYPE INTERFACE_TYPE_MAX = _NOS;
constexpr int INTERFACE_TYPE_ARRAYSIZE = INTERFACE_TYPE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* INTERFACE_TYPE_descriptor();
template<typename T>
inline const std::string& INTERFACE_TYPE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, INTERFACE_TYPE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function INTERFACE_TYPE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    INTERFACE_TYPE_descriptor(), enum_t_value);
}
inline bool INTERFACE_TYPE_Parse(
    const std::string& name, INTERFACE_TYPE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<INTERFACE_TYPE>(
    INTERFACE_TYPE_descriptor(), name, value);
}
enum ACTIVATION_STATUS_TYPE : int {
  _DEVICE_ACTIVATED = 0,
  _DEVICE_DEACTIVATED = 1,
  ACTIVATION_STATUS_TYPE_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ACTIVATION_STATUS_TYPE_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ACTIVATION_STATUS_TYPE_IsValid(int value);
constexpr ACTIVATION_STATUS_TYPE ACTIVATION_STATUS_TYPE_MIN = _DEVICE_ACTIVATED;
constexpr ACTIVATION_STATUS_TYPE ACTIVATION_STATUS_TYPE_MAX = _DEVICE_DEACTIVATED;
constexpr int ACTIVATION_STATUS_TYPE_ARRAYSIZE = ACTIVATION_STATUS_TYPE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ACTIVATION_STATUS_TYPE_descriptor();
template<typename T>
inline const std::string& ACTIVATION_STATUS_TYPE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ACTIVATION_STATUS_TYPE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ACTIVATION_STATUS_TYPE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ACTIVATION_STATUS_TYPE_descriptor(), enum_t_value);
}
inline bool ACTIVATION_STATUS_TYPE_Parse(
    const std::string& name, ACTIVATION_STATUS_TYPE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ACTIVATION_STATUS_TYPE>(
    ACTIVATION_STATUS_TYPE_descriptor(), name, value);
}
enum REGISTRATION_STATUS_TYPE : int {
  _DEVICE_REGISTERED = 0,
  _DEVICE_DEREGISTERED = 1,
  REGISTRATION_STATUS_TYPE_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  REGISTRATION_STATUS_TYPE_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool REGISTRATION_STATUS_TYPE_IsValid(int value);
constexpr REGISTRATION_STATUS_TYPE REGISTRATION_STATUS_TYPE_MIN = _DEVICE_REGISTERED;
constexpr REGISTRATION_STATUS_TYPE REGISTRATION_STATUS_TYPE_MAX = _DEVICE_DEREGISTERED;
constexpr int REGISTRATION_STATUS_TYPE_ARRAYSIZE = REGISTRATION_STATUS_TYPE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* REGISTRATION_STATUS_TYPE_descriptor();
template<typename T>
inline const std::string& REGISTRATION_STATUS_TYPE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, REGISTRATION_STATUS_TYPE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function REGISTRATION_STATUS_TYPE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    REGISTRATION_STATUS_TYPE_descriptor(), enum_t_value);
}
inline bool REGISTRATION_STATUS_TYPE_Parse(
    const std::string& name, REGISTRATION_STATUS_TYPE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<REGISTRATION_STATUS_TYPE>(
    REGISTRATION_STATUS_TYPE_descriptor(), name, value);
}
// ===================================================================

class sessionId PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openoffload.v1alpha2.sessionId) */ {
 public:
  inline sessionId() : sessionId(nullptr) {};
  virtual ~sessionId();

  sessionId(const sessionId& from);
  sessionId(sessionId&& from) noexcept
    : sessionId() {
    *this = ::std::move(from);
  }

  inline sessionId& operator=(const sessionId& from) {
    CopyFrom(from);
    return *this;
  }
  inline sessionId& operator=(sessionId&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const sessionId& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const sessionId* internal_default_instance() {
    return reinterpret_cast<const sessionId*>(
               &_sessionId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(sessionId& a, sessionId& b) {
    a.Swap(&b);
  }
  inline void Swap(sessionId* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(sessionId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline sessionId* New() const final {
    return CreateMaybeMessage<sessionId>(nullptr);
  }

  sessionId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<sessionId>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const sessionId& from);
  void MergeFrom(const sessionId& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(sessionId* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openoffload.v1alpha2.sessionId";
  }
  protected:
  explicit sessionId(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_openoffload_2eproto);
    return ::descriptor_table_openoffload_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
  };
  // int64 sessionId = 1;
  void clear_sessionid();
  ::PROTOBUF_NAMESPACE_ID::int64 sessionid() const;
  void set_sessionid(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_sessionid() const;
  void _internal_set_sessionid(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:openoffload.v1alpha2.sessionId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 sessionid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_openoffload_2eproto;
};
// -------------------------------------------------------------------

class actionType PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openoffload.v1alpha2.actionType) */ {
 public:
  inline actionType() : actionType(nullptr) {};
  virtual ~actionType();

  actionType(const actionType& from);
  actionType(actionType&& from) noexcept
    : actionType() {
    *this = ::std::move(from);
  }

  inline actionType& operator=(const actionType& from) {
    CopyFrom(from);
    return *this;
  }
  inline actionType& operator=(actionType&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const actionType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const actionType* internal_default_instance() {
    return reinterpret_cast<const actionType*>(
               &_actionType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(actionType& a, actionType& b) {
    a.Swap(&b);
  }
  inline void Swap(actionType* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(actionType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline actionType* New() const final {
    return CreateMaybeMessage<actionType>(nullptr);
  }

  actionType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<actionType>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const actionType& from);
  void MergeFrom(const actionType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(actionType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openoffload.v1alpha2.actionType";
  }
  protected:
  explicit actionType(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_openoffload_2eproto);
    return ::descriptor_table_openoffload_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionNextHopFieldNumber = 2,
    kActionTypeFieldNumber = 1,
  };
  // string actionNextHop = 2;
  void clear_actionnexthop();
  const std::string& actionnexthop() const;
  void set_actionnexthop(const std::string& value);
  void set_actionnexthop(std::string&& value);
  void set_actionnexthop(const char* value);
  void set_actionnexthop(const char* value, size_t size);
  std::string* mutable_actionnexthop();
  std::string* release_actionnexthop();
  void set_allocated_actionnexthop(std::string* actionnexthop);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_actionnexthop();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_actionnexthop(
      std::string* actionnexthop);
  private:
  const std::string& _internal_actionnexthop() const;
  void _internal_set_actionnexthop(const std::string& value);
  std::string* _internal_mutable_actionnexthop();
  public:

  // .openoffload.v1alpha2.ACTION_TYPE actionType = 1;
  void clear_actiontype();
  ::openoffload::v1alpha2::ACTION_TYPE actiontype() const;
  void set_actiontype(::openoffload::v1alpha2::ACTION_TYPE value);
  private:
  ::openoffload::v1alpha2::ACTION_TYPE _internal_actiontype() const;
  void _internal_set_actiontype(::openoffload::v1alpha2::ACTION_TYPE value);
  public:

  // @@protoc_insertion_point(class_scope:openoffload.v1alpha2.actionType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr actionnexthop_;
  int actiontype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_openoffload_2eproto;
};
// -------------------------------------------------------------------

class sessionRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openoffload.v1alpha2.sessionRequest) */ {
 public:
  inline sessionRequest() : sessionRequest(nullptr) {};
  virtual ~sessionRequest();

  sessionRequest(const sessionRequest& from);
  sessionRequest(sessionRequest&& from) noexcept
    : sessionRequest() {
    *this = ::std::move(from);
  }

  inline sessionRequest& operator=(const sessionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline sessionRequest& operator=(sessionRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const sessionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const sessionRequest* internal_default_instance() {
    return reinterpret_cast<const sessionRequest*>(
               &_sessionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(sessionRequest& a, sessionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(sessionRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(sessionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline sessionRequest* New() const final {
    return CreateMaybeMessage<sessionRequest>(nullptr);
  }

  sessionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<sessionRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const sessionRequest& from);
  void MergeFrom(const sessionRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(sessionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openoffload.v1alpha2.sessionRequest";
  }
  protected:
  explicit sessionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_openoffload_2eproto);
    return ::descriptor_table_openoffload_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceIpFieldNumber = 4,
    kDestinationIpFieldNumber = 6,
    kActionFieldNumber = 9,
    kInLifFieldNumber = 1,
    kOutLifFieldNumber = 2,
    kIpVersionFieldNumber = 3,
    kSourcePortFieldNumber = 5,
    kDestinationPortFieldNumber = 7,
    kProtocolIdFieldNumber = 8,
  };
  // bytes sourceIp = 4;
  void clear_sourceip();
  const std::string& sourceip() const;
  void set_sourceip(const std::string& value);
  void set_sourceip(std::string&& value);
  void set_sourceip(const char* value);
  void set_sourceip(const void* value, size_t size);
  std::string* mutable_sourceip();
  std::string* release_sourceip();
  void set_allocated_sourceip(std::string* sourceip);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_sourceip();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_sourceip(
      std::string* sourceip);
  private:
  const std::string& _internal_sourceip() const;
  void _internal_set_sourceip(const std::string& value);
  std::string* _internal_mutable_sourceip();
  public:

  // bytes destinationIp = 6;
  void clear_destinationip();
  const std::string& destinationip() const;
  void set_destinationip(const std::string& value);
  void set_destinationip(std::string&& value);
  void set_destinationip(const char* value);
  void set_destinationip(const void* value, size_t size);
  std::string* mutable_destinationip();
  std::string* release_destinationip();
  void set_allocated_destinationip(std::string* destinationip);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_destinationip();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_destinationip(
      std::string* destinationip);
  private:
  const std::string& _internal_destinationip() const;
  void _internal_set_destinationip(const std::string& value);
  std::string* _internal_mutable_destinationip();
  public:

  // .openoffload.v1alpha2.actionType action = 9;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  const ::openoffload::v1alpha2::actionType& action() const;
  ::openoffload::v1alpha2::actionType* release_action();
  ::openoffload::v1alpha2::actionType* mutable_action();
  void set_allocated_action(::openoffload::v1alpha2::actionType* action);
  private:
  const ::openoffload::v1alpha2::actionType& _internal_action() const;
  ::openoffload::v1alpha2::actionType* _internal_mutable_action();
  public:
  void unsafe_arena_set_allocated_action(
      ::openoffload::v1alpha2::actionType* action);
  ::openoffload::v1alpha2::actionType* unsafe_arena_release_action();

  // uint32 inLif = 1;
  void clear_inlif();
  ::PROTOBUF_NAMESPACE_ID::uint32 inlif() const;
  void set_inlif(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_inlif() const;
  void _internal_set_inlif(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 outLif = 2;
  void clear_outlif();
  ::PROTOBUF_NAMESPACE_ID::uint32 outlif() const;
  void set_outlif(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_outlif() const;
  void _internal_set_outlif(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .openoffload.v1alpha2.IP_VERSION ipVersion = 3;
  void clear_ipversion();
  ::openoffload::v1alpha2::IP_VERSION ipversion() const;
  void set_ipversion(::openoffload::v1alpha2::IP_VERSION value);
  private:
  ::openoffload::v1alpha2::IP_VERSION _internal_ipversion() const;
  void _internal_set_ipversion(::openoffload::v1alpha2::IP_VERSION value);
  public:

  // uint32 sourcePort = 5;
  void clear_sourceport();
  ::PROTOBUF_NAMESPACE_ID::uint32 sourceport() const;
  void set_sourceport(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_sourceport() const;
  void _internal_set_sourceport(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 destinationPort = 7;
  void clear_destinationport();
  ::PROTOBUF_NAMESPACE_ID::uint32 destinationport() const;
  void set_destinationport(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_destinationport() const;
  void _internal_set_destinationport(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .openoffload.v1alpha2.PROTOCOL_ID protocolId = 8;
  void clear_protocolid();
  ::openoffload::v1alpha2::PROTOCOL_ID protocolid() const;
  void set_protocolid(::openoffload::v1alpha2::PROTOCOL_ID value);
  private:
  ::openoffload::v1alpha2::PROTOCOL_ID _internal_protocolid() const;
  void _internal_set_protocolid(::openoffload::v1alpha2::PROTOCOL_ID value);
  public:

  // @@protoc_insertion_point(class_scope:openoffload.v1alpha2.sessionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourceip_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destinationip_;
  ::openoffload::v1alpha2::actionType* action_;
  ::PROTOBUF_NAMESPACE_ID::uint32 inlif_;
  ::PROTOBUF_NAMESPACE_ID::uint32 outlif_;
  int ipversion_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sourceport_;
  ::PROTOBUF_NAMESPACE_ID::uint32 destinationport_;
  int protocolid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_openoffload_2eproto;
};
// -------------------------------------------------------------------

class addSessionResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openoffload.v1alpha2.addSessionResponse) */ {
 public:
  inline addSessionResponse() : addSessionResponse(nullptr) {};
  virtual ~addSessionResponse();

  addSessionResponse(const addSessionResponse& from);
  addSessionResponse(addSessionResponse&& from) noexcept
    : addSessionResponse() {
    *this = ::std::move(from);
  }

  inline addSessionResponse& operator=(const addSessionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline addSessionResponse& operator=(addSessionResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const addSessionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const addSessionResponse* internal_default_instance() {
    return reinterpret_cast<const addSessionResponse*>(
               &_addSessionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(addSessionResponse& a, addSessionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(addSessionResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(addSessionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline addSessionResponse* New() const final {
    return CreateMaybeMessage<addSessionResponse>(nullptr);
  }

  addSessionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<addSessionResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const addSessionResponse& from);
  void MergeFrom(const addSessionResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(addSessionResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openoffload.v1alpha2.addSessionResponse";
  }
  protected:
  explicit addSessionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_openoffload_2eproto);
    return ::descriptor_table_openoffload_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartTimeFieldNumber = 3,
    kSessionIdFieldNumber = 1,
    kRequestStatusFieldNumber = 2,
  };
  // .google.protobuf.Timestamp startTime = 3;
  bool has_starttime() const;
  private:
  bool _internal_has_starttime() const;
  public:
  void clear_starttime();
  const PROTOBUF_NAMESPACE_ID::Timestamp& starttime() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_starttime();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_starttime();
  void set_allocated_starttime(PROTOBUF_NAMESPACE_ID::Timestamp* starttime);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_starttime() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_starttime();
  public:
  void unsafe_arena_set_allocated_starttime(
      PROTOBUF_NAMESPACE_ID::Timestamp* starttime);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_starttime();

  // int64 sessionId = 1;
  void clear_sessionid();
  ::PROTOBUF_NAMESPACE_ID::int64 sessionid() const;
  void set_sessionid(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_sessionid() const;
  void _internal_set_sessionid(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .openoffload.v1alpha2.REQUEST_STATUS requestStatus = 2;
  void clear_requeststatus();
  ::openoffload::v1alpha2::REQUEST_STATUS requeststatus() const;
  void set_requeststatus(::openoffload::v1alpha2::REQUEST_STATUS value);
  private:
  ::openoffload::v1alpha2::REQUEST_STATUS _internal_requeststatus() const;
  void _internal_set_requeststatus(::openoffload::v1alpha2::REQUEST_STATUS value);
  public:

  // @@protoc_insertion_point(class_scope:openoffload.v1alpha2.addSessionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  PROTOBUF_NAMESPACE_ID::Timestamp* starttime_;
  ::PROTOBUF_NAMESPACE_ID::int64 sessionid_;
  int requeststatus_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_openoffload_2eproto;
};
// -------------------------------------------------------------------

class sessionResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openoffload.v1alpha2.sessionResponse) */ {
 public:
  inline sessionResponse() : sessionResponse(nullptr) {};
  virtual ~sessionResponse();

  sessionResponse(const sessionResponse& from);
  sessionResponse(sessionResponse&& from) noexcept
    : sessionResponse() {
    *this = ::std::move(from);
  }

  inline sessionResponse& operator=(const sessionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline sessionResponse& operator=(sessionResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const sessionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const sessionResponse* internal_default_instance() {
    return reinterpret_cast<const sessionResponse*>(
               &_sessionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(sessionResponse& a, sessionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(sessionResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(sessionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline sessionResponse* New() const final {
    return CreateMaybeMessage<sessionResponse>(nullptr);
  }

  sessionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<sessionResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const sessionResponse& from);
  void MergeFrom(const sessionResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(sessionResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openoffload.v1alpha2.sessionResponse";
  }
  protected:
  explicit sessionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_openoffload_2eproto);
    return ::descriptor_table_openoffload_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartTimeFieldNumber = 9,
    kEndTimeFieldNumber = 10,
    kSessionIdFieldNumber = 1,
    kInPacketsFieldNumber = 2,
    kOutPacketsFieldNumber = 3,
    kInBytesFieldNumber = 4,
    kOutBytesFieldNumber = 5,
    kSessionStateFieldNumber = 6,
    kSessionCloseCodeFieldNumber = 7,
    kRequestStatusFieldNumber = 8,
  };
  // .google.protobuf.Timestamp startTime = 9;
  bool has_starttime() const;
  private:
  bool _internal_has_starttime() const;
  public:
  void clear_starttime();
  const PROTOBUF_NAMESPACE_ID::Timestamp& starttime() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_starttime();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_starttime();
  void set_allocated_starttime(PROTOBUF_NAMESPACE_ID::Timestamp* starttime);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_starttime() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_starttime();
  public:
  void unsafe_arena_set_allocated_starttime(
      PROTOBUF_NAMESPACE_ID::Timestamp* starttime);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_starttime();

  // .google.protobuf.Timestamp endTime = 10;
  bool has_endtime() const;
  private:
  bool _internal_has_endtime() const;
  public:
  void clear_endtime();
  const PROTOBUF_NAMESPACE_ID::Timestamp& endtime() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_endtime();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_endtime();
  void set_allocated_endtime(PROTOBUF_NAMESPACE_ID::Timestamp* endtime);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_endtime() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_endtime();
  public:
  void unsafe_arena_set_allocated_endtime(
      PROTOBUF_NAMESPACE_ID::Timestamp* endtime);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_endtime();

  // int64 sessionId = 1;
  void clear_sessionid();
  ::PROTOBUF_NAMESPACE_ID::int64 sessionid() const;
  void set_sessionid(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_sessionid() const;
  void _internal_set_sessionid(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 inPackets = 2;
  void clear_inpackets();
  ::PROTOBUF_NAMESPACE_ID::int64 inpackets() const;
  void set_inpackets(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_inpackets() const;
  void _internal_set_inpackets(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 outPackets = 3;
  void clear_outpackets();
  ::PROTOBUF_NAMESPACE_ID::int64 outpackets() const;
  void set_outpackets(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_outpackets() const;
  void _internal_set_outpackets(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 inBytes = 4;
  void clear_inbytes();
  ::PROTOBUF_NAMESPACE_ID::int64 inbytes() const;
  void set_inbytes(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_inbytes() const;
  void _internal_set_inbytes(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 outBytes = 5;
  void clear_outbytes();
  ::PROTOBUF_NAMESPACE_ID::int64 outbytes() const;
  void set_outbytes(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_outbytes() const;
  void _internal_set_outbytes(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .openoffload.v1alpha2.SESSION_STATE sessionState = 6;
  void clear_sessionstate();
  ::openoffload::v1alpha2::SESSION_STATE sessionstate() const;
  void set_sessionstate(::openoffload::v1alpha2::SESSION_STATE value);
  private:
  ::openoffload::v1alpha2::SESSION_STATE _internal_sessionstate() const;
  void _internal_set_sessionstate(::openoffload::v1alpha2::SESSION_STATE value);
  public:

  // .openoffload.v1alpha2.SESSION_CLOSE_CODE sessionCloseCode = 7;
  void clear_sessionclosecode();
  ::openoffload::v1alpha2::SESSION_CLOSE_CODE sessionclosecode() const;
  void set_sessionclosecode(::openoffload::v1alpha2::SESSION_CLOSE_CODE value);
  private:
  ::openoffload::v1alpha2::SESSION_CLOSE_CODE _internal_sessionclosecode() const;
  void _internal_set_sessionclosecode(::openoffload::v1alpha2::SESSION_CLOSE_CODE value);
  public:

  // .openoffload.v1alpha2.REQUEST_STATUS requestStatus = 8;
  void clear_requeststatus();
  ::openoffload::v1alpha2::REQUEST_STATUS requeststatus() const;
  void set_requeststatus(::openoffload::v1alpha2::REQUEST_STATUS value);
  private:
  ::openoffload::v1alpha2::REQUEST_STATUS _internal_requeststatus() const;
  void _internal_set_requeststatus(::openoffload::v1alpha2::REQUEST_STATUS value);
  public:

  // @@protoc_insertion_point(class_scope:openoffload.v1alpha2.sessionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  PROTOBUF_NAMESPACE_ID::Timestamp* starttime_;
  PROTOBUF_NAMESPACE_ID::Timestamp* endtime_;
  ::PROTOBUF_NAMESPACE_ID::int64 sessionid_;
  ::PROTOBUF_NAMESPACE_ID::int64 inpackets_;
  ::PROTOBUF_NAMESPACE_ID::int64 outpackets_;
  ::PROTOBUF_NAMESPACE_ID::int64 inbytes_;
  ::PROTOBUF_NAMESPACE_ID::int64 outbytes_;
  int sessionstate_;
  int sessionclosecode_;
  int requeststatus_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_openoffload_2eproto;
};
// -------------------------------------------------------------------

class statisticsRequestArgs PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openoffload.v1alpha2.statisticsRequestArgs) */ {
 public:
  inline statisticsRequestArgs() : statisticsRequestArgs(nullptr) {};
  virtual ~statisticsRequestArgs();

  statisticsRequestArgs(const statisticsRequestArgs& from);
  statisticsRequestArgs(statisticsRequestArgs&& from) noexcept
    : statisticsRequestArgs() {
    *this = ::std::move(from);
  }

  inline statisticsRequestArgs& operator=(const statisticsRequestArgs& from) {
    CopyFrom(from);
    return *this;
  }
  inline statisticsRequestArgs& operator=(statisticsRequestArgs&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const statisticsRequestArgs& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const statisticsRequestArgs* internal_default_instance() {
    return reinterpret_cast<const statisticsRequestArgs*>(
               &_statisticsRequestArgs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(statisticsRequestArgs& a, statisticsRequestArgs& b) {
    a.Swap(&b);
  }
  inline void Swap(statisticsRequestArgs* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(statisticsRequestArgs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline statisticsRequestArgs* New() const final {
    return CreateMaybeMessage<statisticsRequestArgs>(nullptr);
  }

  statisticsRequestArgs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<statisticsRequestArgs>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const statisticsRequestArgs& from);
  void MergeFrom(const statisticsRequestArgs& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(statisticsRequestArgs* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openoffload.v1alpha2.statisticsRequestArgs";
  }
  protected:
  explicit statisticsRequestArgs(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_openoffload_2eproto);
    return ::descriptor_table_openoffload_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPageSizeFieldNumber = 1,
  };
  // int32 pageSize = 1;
  void clear_pagesize();
  ::PROTOBUF_NAMESPACE_ID::int32 pagesize() const;
  void set_pagesize(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_pagesize() const;
  void _internal_set_pagesize(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:openoffload.v1alpha2.statisticsRequestArgs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 pagesize_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_openoffload_2eproto;
};
// -------------------------------------------------------------------

class Empty PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openoffload.v1alpha2.Empty) */ {
 public:
  inline Empty() : Empty(nullptr) {};
  virtual ~Empty();

  Empty(const Empty& from);
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  inline Empty& operator=(Empty&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Empty& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }
  inline void Swap(Empty* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Empty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Empty* New() const final {
    return CreateMaybeMessage<Empty>(nullptr);
  }

  Empty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Empty& from);
  void MergeFrom(const Empty& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Empty* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openoffload.v1alpha2.Empty";
  }
  protected:
  explicit Empty(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_openoffload_2eproto);
    return ::descriptor_table_openoffload_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:openoffload.v1alpha2.Empty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_openoffload_2eproto;
};
// -------------------------------------------------------------------

class deviceDescription PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openoffload.v1alpha2.deviceDescription) */ {
 public:
  inline deviceDescription() : deviceDescription(nullptr) {};
  virtual ~deviceDescription();

  deviceDescription(const deviceDescription& from);
  deviceDescription(deviceDescription&& from) noexcept
    : deviceDescription() {
    *this = ::std::move(from);
  }

  inline deviceDescription& operator=(const deviceDescription& from) {
    CopyFrom(from);
    return *this;
  }
  inline deviceDescription& operator=(deviceDescription&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const deviceDescription& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const deviceDescription* internal_default_instance() {
    return reinterpret_cast<const deviceDescription*>(
               &_deviceDescription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(deviceDescription& a, deviceDescription& b) {
    a.Swap(&b);
  }
  inline void Swap(deviceDescription* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(deviceDescription* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline deviceDescription* New() const final {
    return CreateMaybeMessage<deviceDescription>(nullptr);
  }

  deviceDescription* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<deviceDescription>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const deviceDescription& from);
  void MergeFrom(const deviceDescription& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(deviceDescription* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openoffload.v1alpha2.deviceDescription";
  }
  protected:
  explicit deviceDescription(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_openoffload_2eproto);
    return ::descriptor_table_openoffload_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDescriptionFieldNumber = 3,
    kTypeFieldNumber = 2,
    kSessionCapacityFieldNumber = 4,
    kSessionRateFieldNumber = 5,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  void set_description(const std::string& value);
  void set_description(std::string&& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  std::string* mutable_description();
  std::string* release_description();
  void set_allocated_description(std::string* description);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_description();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_description(
      std::string* description);
  private:
  const std::string& _internal_description() const;
  void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .openoffload.v1alpha2.INTERFACE_TYPE type = 2;
  void clear_type();
  ::openoffload::v1alpha2::INTERFACE_TYPE type() const;
  void set_type(::openoffload::v1alpha2::INTERFACE_TYPE value);
  private:
  ::openoffload::v1alpha2::INTERFACE_TYPE _internal_type() const;
  void _internal_set_type(::openoffload::v1alpha2::INTERFACE_TYPE value);
  public:

  // int32 sessionCapacity = 4;
  void clear_sessioncapacity();
  ::PROTOBUF_NAMESPACE_ID::int32 sessioncapacity() const;
  void set_sessioncapacity(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_sessioncapacity() const;
  void _internal_set_sessioncapacity(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 sessionRate = 5;
  void clear_sessionrate();
  ::PROTOBUF_NAMESPACE_ID::int32 sessionrate() const;
  void set_sessionrate(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_sessionrate() const;
  void _internal_set_sessionrate(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:openoffload.v1alpha2.deviceDescription)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  int type_;
  ::PROTOBUF_NAMESPACE_ID::int32 sessioncapacity_;
  ::PROTOBUF_NAMESPACE_ID::int32 sessionrate_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_openoffload_2eproto;
};
// -------------------------------------------------------------------

class deviceList PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openoffload.v1alpha2.deviceList) */ {
 public:
  inline deviceList() : deviceList(nullptr) {};
  virtual ~deviceList();

  deviceList(const deviceList& from);
  deviceList(deviceList&& from) noexcept
    : deviceList() {
    *this = ::std::move(from);
  }

  inline deviceList& operator=(const deviceList& from) {
    CopyFrom(from);
    return *this;
  }
  inline deviceList& operator=(deviceList&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const deviceList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const deviceList* internal_default_instance() {
    return reinterpret_cast<const deviceList*>(
               &_deviceList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(deviceList& a, deviceList& b) {
    a.Swap(&b);
  }
  inline void Swap(deviceList* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(deviceList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline deviceList* New() const final {
    return CreateMaybeMessage<deviceList>(nullptr);
  }

  deviceList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<deviceList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const deviceList& from);
  void MergeFrom(const deviceList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(deviceList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openoffload.v1alpha2.deviceList";
  }
  protected:
  explicit deviceList(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_openoffload_2eproto);
    return ::descriptor_table_openoffload_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevicesFieldNumber = 1,
  };
  // repeated .openoffload.v1alpha2.deviceDescription devices = 1;
  int devices_size() const;
  private:
  int _internal_devices_size() const;
  public:
  void clear_devices();
  ::openoffload::v1alpha2::deviceDescription* mutable_devices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openoffload::v1alpha2::deviceDescription >*
      mutable_devices();
  private:
  const ::openoffload::v1alpha2::deviceDescription& _internal_devices(int index) const;
  ::openoffload::v1alpha2::deviceDescription* _internal_add_devices();
  public:
  const ::openoffload::v1alpha2::deviceDescription& devices(int index) const;
  ::openoffload::v1alpha2::deviceDescription* add_devices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openoffload::v1alpha2::deviceDescription >&
      devices() const;

  // @@protoc_insertion_point(class_scope:openoffload.v1alpha2.deviceList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openoffload::v1alpha2::deviceDescription > devices_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_openoffload_2eproto;
};
// -------------------------------------------------------------------

class registrationStatus PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openoffload.v1alpha2.registrationStatus) */ {
 public:
  inline registrationStatus() : registrationStatus(nullptr) {};
  virtual ~registrationStatus();

  registrationStatus(const registrationStatus& from);
  registrationStatus(registrationStatus&& from) noexcept
    : registrationStatus() {
    *this = ::std::move(from);
  }

  inline registrationStatus& operator=(const registrationStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline registrationStatus& operator=(registrationStatus&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const registrationStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const registrationStatus* internal_default_instance() {
    return reinterpret_cast<const registrationStatus*>(
               &_registrationStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(registrationStatus& a, registrationStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(registrationStatus* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(registrationStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline registrationStatus* New() const final {
    return CreateMaybeMessage<registrationStatus>(nullptr);
  }

  registrationStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<registrationStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const registrationStatus& from);
  void MergeFrom(const registrationStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(registrationStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openoffload.v1alpha2.registrationStatus";
  }
  protected:
  explicit registrationStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_openoffload_2eproto);
    return ::descriptor_table_openoffload_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .openoffload.v1alpha2.REGISTRATION_STATUS_TYPE status = 1;
  void clear_status();
  ::openoffload::v1alpha2::REGISTRATION_STATUS_TYPE status() const;
  void set_status(::openoffload::v1alpha2::REGISTRATION_STATUS_TYPE value);
  private:
  ::openoffload::v1alpha2::REGISTRATION_STATUS_TYPE _internal_status() const;
  void _internal_set_status(::openoffload::v1alpha2::REGISTRATION_STATUS_TYPE value);
  public:

  // @@protoc_insertion_point(class_scope:openoffload.v1alpha2.registrationStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_openoffload_2eproto;
};
// -------------------------------------------------------------------

class activationStatus PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:openoffload.v1alpha2.activationStatus) */ {
 public:
  inline activationStatus() : activationStatus(nullptr) {};
  virtual ~activationStatus();

  activationStatus(const activationStatus& from);
  activationStatus(activationStatus&& from) noexcept
    : activationStatus() {
    *this = ::std::move(from);
  }

  inline activationStatus& operator=(const activationStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline activationStatus& operator=(activationStatus&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const activationStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const activationStatus* internal_default_instance() {
    return reinterpret_cast<const activationStatus*>(
               &_activationStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(activationStatus& a, activationStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(activationStatus* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(activationStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline activationStatus* New() const final {
    return CreateMaybeMessage<activationStatus>(nullptr);
  }

  activationStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<activationStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const activationStatus& from);
  void MergeFrom(const activationStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(activationStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openoffload.v1alpha2.activationStatus";
  }
  protected:
  explicit activationStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_openoffload_2eproto);
    return ::descriptor_table_openoffload_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // .openoffload.v1alpha2.deviceDescription device = 2;
  bool has_device() const;
  private:
  bool _internal_has_device() const;
  public:
  void clear_device();
  const ::openoffload::v1alpha2::deviceDescription& device() const;
  ::openoffload::v1alpha2::deviceDescription* release_device();
  ::openoffload::v1alpha2::deviceDescription* mutable_device();
  void set_allocated_device(::openoffload::v1alpha2::deviceDescription* device);
  private:
  const ::openoffload::v1alpha2::deviceDescription& _internal_device() const;
  ::openoffload::v1alpha2::deviceDescription* _internal_mutable_device();
  public:
  void unsafe_arena_set_allocated_device(
      ::openoffload::v1alpha2::deviceDescription* device);
  ::openoffload::v1alpha2::deviceDescription* unsafe_arena_release_device();

  // .openoffload.v1alpha2.ACTIVATION_STATUS_TYPE status = 1;
  void clear_status();
  ::openoffload::v1alpha2::ACTIVATION_STATUS_TYPE status() const;
  void set_status(::openoffload::v1alpha2::ACTIVATION_STATUS_TYPE value);
  private:
  ::openoffload::v1alpha2::ACTIVATION_STATUS_TYPE _internal_status() const;
  void _internal_set_status(::openoffload::v1alpha2::ACTIVATION_STATUS_TYPE value);
  public:

  // @@protoc_insertion_point(class_scope:openoffload.v1alpha2.activationStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::openoffload::v1alpha2::deviceDescription* device_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_openoffload_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// sessionId

// int64 sessionId = 1;
inline void sessionId::clear_sessionid() {
  sessionid_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 sessionId::_internal_sessionid() const {
  return sessionid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 sessionId::sessionid() const {
  // @@protoc_insertion_point(field_get:openoffload.v1alpha2.sessionId.sessionId)
  return _internal_sessionid();
}
inline void sessionId::_internal_set_sessionid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  sessionid_ = value;
}
inline void sessionId::set_sessionid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_sessionid(value);
  // @@protoc_insertion_point(field_set:openoffload.v1alpha2.sessionId.sessionId)
}

// -------------------------------------------------------------------

// actionType

// .openoffload.v1alpha2.ACTION_TYPE actionType = 1;
inline void actionType::clear_actiontype() {
  actiontype_ = 0;
}
inline ::openoffload::v1alpha2::ACTION_TYPE actionType::_internal_actiontype() const {
  return static_cast< ::openoffload::v1alpha2::ACTION_TYPE >(actiontype_);
}
inline ::openoffload::v1alpha2::ACTION_TYPE actionType::actiontype() const {
  // @@protoc_insertion_point(field_get:openoffload.v1alpha2.actionType.actionType)
  return _internal_actiontype();
}
inline void actionType::_internal_set_actiontype(::openoffload::v1alpha2::ACTION_TYPE value) {
  
  actiontype_ = value;
}
inline void actionType::set_actiontype(::openoffload::v1alpha2::ACTION_TYPE value) {
  _internal_set_actiontype(value);
  // @@protoc_insertion_point(field_set:openoffload.v1alpha2.actionType.actionType)
}

// string actionNextHop = 2;
inline void actionType::clear_actionnexthop() {
  actionnexthop_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& actionType::actionnexthop() const {
  // @@protoc_insertion_point(field_get:openoffload.v1alpha2.actionType.actionNextHop)
  return _internal_actionnexthop();
}
inline void actionType::set_actionnexthop(const std::string& value) {
  _internal_set_actionnexthop(value);
  // @@protoc_insertion_point(field_set:openoffload.v1alpha2.actionType.actionNextHop)
}
inline std::string* actionType::mutable_actionnexthop() {
  // @@protoc_insertion_point(field_mutable:openoffload.v1alpha2.actionType.actionNextHop)
  return _internal_mutable_actionnexthop();
}
inline const std::string& actionType::_internal_actionnexthop() const {
  return actionnexthop_.Get();
}
inline void actionType::_internal_set_actionnexthop(const std::string& value) {
  
  actionnexthop_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void actionType::set_actionnexthop(std::string&& value) {
  
  actionnexthop_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:openoffload.v1alpha2.actionType.actionNextHop)
}
inline void actionType::set_actionnexthop(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  actionnexthop_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:openoffload.v1alpha2.actionType.actionNextHop)
}
inline void actionType::set_actionnexthop(const char* value,
    size_t size) {
  
  actionnexthop_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:openoffload.v1alpha2.actionType.actionNextHop)
}
inline std::string* actionType::_internal_mutable_actionnexthop() {
  
  return actionnexthop_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* actionType::release_actionnexthop() {
  // @@protoc_insertion_point(field_release:openoffload.v1alpha2.actionType.actionNextHop)
  return actionnexthop_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void actionType::set_allocated_actionnexthop(std::string* actionnexthop) {
  if (actionnexthop != nullptr) {
    
  } else {
    
  }
  actionnexthop_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), actionnexthop,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:openoffload.v1alpha2.actionType.actionNextHop)
}
inline std::string* actionType::unsafe_arena_release_actionnexthop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:openoffload.v1alpha2.actionType.actionNextHop)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return actionnexthop_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void actionType::unsafe_arena_set_allocated_actionnexthop(
    std::string* actionnexthop) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (actionnexthop != nullptr) {
    
  } else {
    
  }
  actionnexthop_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      actionnexthop, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openoffload.v1alpha2.actionType.actionNextHop)
}

// -------------------------------------------------------------------

// sessionRequest

// uint32 inLif = 1;
inline void sessionRequest::clear_inlif() {
  inlif_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 sessionRequest::_internal_inlif() const {
  return inlif_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 sessionRequest::inlif() const {
  // @@protoc_insertion_point(field_get:openoffload.v1alpha2.sessionRequest.inLif)
  return _internal_inlif();
}
inline void sessionRequest::_internal_set_inlif(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  inlif_ = value;
}
inline void sessionRequest::set_inlif(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_inlif(value);
  // @@protoc_insertion_point(field_set:openoffload.v1alpha2.sessionRequest.inLif)
}

// uint32 outLif = 2;
inline void sessionRequest::clear_outlif() {
  outlif_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 sessionRequest::_internal_outlif() const {
  return outlif_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 sessionRequest::outlif() const {
  // @@protoc_insertion_point(field_get:openoffload.v1alpha2.sessionRequest.outLif)
  return _internal_outlif();
}
inline void sessionRequest::_internal_set_outlif(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  outlif_ = value;
}
inline void sessionRequest::set_outlif(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_outlif(value);
  // @@protoc_insertion_point(field_set:openoffload.v1alpha2.sessionRequest.outLif)
}

// .openoffload.v1alpha2.IP_VERSION ipVersion = 3;
inline void sessionRequest::clear_ipversion() {
  ipversion_ = 0;
}
inline ::openoffload::v1alpha2::IP_VERSION sessionRequest::_internal_ipversion() const {
  return static_cast< ::openoffload::v1alpha2::IP_VERSION >(ipversion_);
}
inline ::openoffload::v1alpha2::IP_VERSION sessionRequest::ipversion() const {
  // @@protoc_insertion_point(field_get:openoffload.v1alpha2.sessionRequest.ipVersion)
  return _internal_ipversion();
}
inline void sessionRequest::_internal_set_ipversion(::openoffload::v1alpha2::IP_VERSION value) {
  
  ipversion_ = value;
}
inline void sessionRequest::set_ipversion(::openoffload::v1alpha2::IP_VERSION value) {
  _internal_set_ipversion(value);
  // @@protoc_insertion_point(field_set:openoffload.v1alpha2.sessionRequest.ipVersion)
}

// bytes sourceIp = 4;
inline void sessionRequest::clear_sourceip() {
  sourceip_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& sessionRequest::sourceip() const {
  // @@protoc_insertion_point(field_get:openoffload.v1alpha2.sessionRequest.sourceIp)
  return _internal_sourceip();
}
inline void sessionRequest::set_sourceip(const std::string& value) {
  _internal_set_sourceip(value);
  // @@protoc_insertion_point(field_set:openoffload.v1alpha2.sessionRequest.sourceIp)
}
inline std::string* sessionRequest::mutable_sourceip() {
  // @@protoc_insertion_point(field_mutable:openoffload.v1alpha2.sessionRequest.sourceIp)
  return _internal_mutable_sourceip();
}
inline const std::string& sessionRequest::_internal_sourceip() const {
  return sourceip_.Get();
}
inline void sessionRequest::_internal_set_sourceip(const std::string& value) {
  
  sourceip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void sessionRequest::set_sourceip(std::string&& value) {
  
  sourceip_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:openoffload.v1alpha2.sessionRequest.sourceIp)
}
inline void sessionRequest::set_sourceip(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  sourceip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:openoffload.v1alpha2.sessionRequest.sourceIp)
}
inline void sessionRequest::set_sourceip(const void* value,
    size_t size) {
  
  sourceip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:openoffload.v1alpha2.sessionRequest.sourceIp)
}
inline std::string* sessionRequest::_internal_mutable_sourceip() {
  
  return sourceip_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* sessionRequest::release_sourceip() {
  // @@protoc_insertion_point(field_release:openoffload.v1alpha2.sessionRequest.sourceIp)
  return sourceip_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void sessionRequest::set_allocated_sourceip(std::string* sourceip) {
  if (sourceip != nullptr) {
    
  } else {
    
  }
  sourceip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sourceip,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:openoffload.v1alpha2.sessionRequest.sourceIp)
}
inline std::string* sessionRequest::unsafe_arena_release_sourceip() {
  // @@protoc_insertion_point(field_unsafe_arena_release:openoffload.v1alpha2.sessionRequest.sourceIp)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return sourceip_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void sessionRequest::unsafe_arena_set_allocated_sourceip(
    std::string* sourceip) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (sourceip != nullptr) {
    
  } else {
    
  }
  sourceip_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      sourceip, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openoffload.v1alpha2.sessionRequest.sourceIp)
}

// uint32 sourcePort = 5;
inline void sessionRequest::clear_sourceport() {
  sourceport_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 sessionRequest::_internal_sourceport() const {
  return sourceport_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 sessionRequest::sourceport() const {
  // @@protoc_insertion_point(field_get:openoffload.v1alpha2.sessionRequest.sourcePort)
  return _internal_sourceport();
}
inline void sessionRequest::_internal_set_sourceport(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  sourceport_ = value;
}
inline void sessionRequest::set_sourceport(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_sourceport(value);
  // @@protoc_insertion_point(field_set:openoffload.v1alpha2.sessionRequest.sourcePort)
}

// bytes destinationIp = 6;
inline void sessionRequest::clear_destinationip() {
  destinationip_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& sessionRequest::destinationip() const {
  // @@protoc_insertion_point(field_get:openoffload.v1alpha2.sessionRequest.destinationIp)
  return _internal_destinationip();
}
inline void sessionRequest::set_destinationip(const std::string& value) {
  _internal_set_destinationip(value);
  // @@protoc_insertion_point(field_set:openoffload.v1alpha2.sessionRequest.destinationIp)
}
inline std::string* sessionRequest::mutable_destinationip() {
  // @@protoc_insertion_point(field_mutable:openoffload.v1alpha2.sessionRequest.destinationIp)
  return _internal_mutable_destinationip();
}
inline const std::string& sessionRequest::_internal_destinationip() const {
  return destinationip_.Get();
}
inline void sessionRequest::_internal_set_destinationip(const std::string& value) {
  
  destinationip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void sessionRequest::set_destinationip(std::string&& value) {
  
  destinationip_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:openoffload.v1alpha2.sessionRequest.destinationIp)
}
inline void sessionRequest::set_destinationip(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  destinationip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:openoffload.v1alpha2.sessionRequest.destinationIp)
}
inline void sessionRequest::set_destinationip(const void* value,
    size_t size) {
  
  destinationip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:openoffload.v1alpha2.sessionRequest.destinationIp)
}
inline std::string* sessionRequest::_internal_mutable_destinationip() {
  
  return destinationip_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* sessionRequest::release_destinationip() {
  // @@protoc_insertion_point(field_release:openoffload.v1alpha2.sessionRequest.destinationIp)
  return destinationip_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void sessionRequest::set_allocated_destinationip(std::string* destinationip) {
  if (destinationip != nullptr) {
    
  } else {
    
  }
  destinationip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), destinationip,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:openoffload.v1alpha2.sessionRequest.destinationIp)
}
inline std::string* sessionRequest::unsafe_arena_release_destinationip() {
  // @@protoc_insertion_point(field_unsafe_arena_release:openoffload.v1alpha2.sessionRequest.destinationIp)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return destinationip_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void sessionRequest::unsafe_arena_set_allocated_destinationip(
    std::string* destinationip) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (destinationip != nullptr) {
    
  } else {
    
  }
  destinationip_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      destinationip, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openoffload.v1alpha2.sessionRequest.destinationIp)
}

// uint32 destinationPort = 7;
inline void sessionRequest::clear_destinationport() {
  destinationport_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 sessionRequest::_internal_destinationport() const {
  return destinationport_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 sessionRequest::destinationport() const {
  // @@protoc_insertion_point(field_get:openoffload.v1alpha2.sessionRequest.destinationPort)
  return _internal_destinationport();
}
inline void sessionRequest::_internal_set_destinationport(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  destinationport_ = value;
}
inline void sessionRequest::set_destinationport(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_destinationport(value);
  // @@protoc_insertion_point(field_set:openoffload.v1alpha2.sessionRequest.destinationPort)
}

// .openoffload.v1alpha2.PROTOCOL_ID protocolId = 8;
inline void sessionRequest::clear_protocolid() {
  protocolid_ = 0;
}
inline ::openoffload::v1alpha2::PROTOCOL_ID sessionRequest::_internal_protocolid() const {
  return static_cast< ::openoffload::v1alpha2::PROTOCOL_ID >(protocolid_);
}
inline ::openoffload::v1alpha2::PROTOCOL_ID sessionRequest::protocolid() const {
  // @@protoc_insertion_point(field_get:openoffload.v1alpha2.sessionRequest.protocolId)
  return _internal_protocolid();
}
inline void sessionRequest::_internal_set_protocolid(::openoffload::v1alpha2::PROTOCOL_ID value) {
  
  protocolid_ = value;
}
inline void sessionRequest::set_protocolid(::openoffload::v1alpha2::PROTOCOL_ID value) {
  _internal_set_protocolid(value);
  // @@protoc_insertion_point(field_set:openoffload.v1alpha2.sessionRequest.protocolId)
}

// .openoffload.v1alpha2.actionType action = 9;
inline bool sessionRequest::_internal_has_action() const {
  return this != internal_default_instance() && action_ != nullptr;
}
inline bool sessionRequest::has_action() const {
  return _internal_has_action();
}
inline void sessionRequest::clear_action() {
  if (GetArena() == nullptr && action_ != nullptr) {
    delete action_;
  }
  action_ = nullptr;
}
inline const ::openoffload::v1alpha2::actionType& sessionRequest::_internal_action() const {
  const ::openoffload::v1alpha2::actionType* p = action_;
  return p != nullptr ? *p : *reinterpret_cast<const ::openoffload::v1alpha2::actionType*>(
      &::openoffload::v1alpha2::_actionType_default_instance_);
}
inline const ::openoffload::v1alpha2::actionType& sessionRequest::action() const {
  // @@protoc_insertion_point(field_get:openoffload.v1alpha2.sessionRequest.action)
  return _internal_action();
}
inline void sessionRequest::unsafe_arena_set_allocated_action(
    ::openoffload::v1alpha2::actionType* action) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(action_);
  }
  action_ = action;
  if (action) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openoffload.v1alpha2.sessionRequest.action)
}
inline ::openoffload::v1alpha2::actionType* sessionRequest::release_action() {
  auto temp = unsafe_arena_release_action();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::openoffload::v1alpha2::actionType* sessionRequest::unsafe_arena_release_action() {
  // @@protoc_insertion_point(field_release:openoffload.v1alpha2.sessionRequest.action)
  
  ::openoffload::v1alpha2::actionType* temp = action_;
  action_ = nullptr;
  return temp;
}
inline ::openoffload::v1alpha2::actionType* sessionRequest::_internal_mutable_action() {
  
  if (action_ == nullptr) {
    auto* p = CreateMaybeMessage<::openoffload::v1alpha2::actionType>(GetArena());
    action_ = p;
  }
  return action_;
}
inline ::openoffload::v1alpha2::actionType* sessionRequest::mutable_action() {
  // @@protoc_insertion_point(field_mutable:openoffload.v1alpha2.sessionRequest.action)
  return _internal_mutable_action();
}
inline void sessionRequest::set_allocated_action(::openoffload::v1alpha2::actionType* action) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete action_;
  }
  if (action) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(action);
    if (message_arena != submessage_arena) {
      action = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, action, submessage_arena);
    }
    
  } else {
    
  }
  action_ = action;
  // @@protoc_insertion_point(field_set_allocated:openoffload.v1alpha2.sessionRequest.action)
}

// -------------------------------------------------------------------

// addSessionResponse

// int64 sessionId = 1;
inline void addSessionResponse::clear_sessionid() {
  sessionid_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 addSessionResponse::_internal_sessionid() const {
  return sessionid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 addSessionResponse::sessionid() const {
  // @@protoc_insertion_point(field_get:openoffload.v1alpha2.addSessionResponse.sessionId)
  return _internal_sessionid();
}
inline void addSessionResponse::_internal_set_sessionid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  sessionid_ = value;
}
inline void addSessionResponse::set_sessionid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_sessionid(value);
  // @@protoc_insertion_point(field_set:openoffload.v1alpha2.addSessionResponse.sessionId)
}

// .openoffload.v1alpha2.REQUEST_STATUS requestStatus = 2;
inline void addSessionResponse::clear_requeststatus() {
  requeststatus_ = 0;
}
inline ::openoffload::v1alpha2::REQUEST_STATUS addSessionResponse::_internal_requeststatus() const {
  return static_cast< ::openoffload::v1alpha2::REQUEST_STATUS >(requeststatus_);
}
inline ::openoffload::v1alpha2::REQUEST_STATUS addSessionResponse::requeststatus() const {
  // @@protoc_insertion_point(field_get:openoffload.v1alpha2.addSessionResponse.requestStatus)
  return _internal_requeststatus();
}
inline void addSessionResponse::_internal_set_requeststatus(::openoffload::v1alpha2::REQUEST_STATUS value) {
  
  requeststatus_ = value;
}
inline void addSessionResponse::set_requeststatus(::openoffload::v1alpha2::REQUEST_STATUS value) {
  _internal_set_requeststatus(value);
  // @@protoc_insertion_point(field_set:openoffload.v1alpha2.addSessionResponse.requestStatus)
}

// .google.protobuf.Timestamp startTime = 3;
inline bool addSessionResponse::_internal_has_starttime() const {
  return this != internal_default_instance() && starttime_ != nullptr;
}
inline bool addSessionResponse::has_starttime() const {
  return _internal_has_starttime();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& addSessionResponse::_internal_starttime() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = starttime_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& addSessionResponse::starttime() const {
  // @@protoc_insertion_point(field_get:openoffload.v1alpha2.addSessionResponse.startTime)
  return _internal_starttime();
}
inline void addSessionResponse::unsafe_arena_set_allocated_starttime(
    PROTOBUF_NAMESPACE_ID::Timestamp* starttime) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(starttime_);
  }
  starttime_ = starttime;
  if (starttime) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openoffload.v1alpha2.addSessionResponse.startTime)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* addSessionResponse::release_starttime() {
  auto temp = unsafe_arena_release_starttime();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* addSessionResponse::unsafe_arena_release_starttime() {
  // @@protoc_insertion_point(field_release:openoffload.v1alpha2.addSessionResponse.startTime)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = starttime_;
  starttime_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* addSessionResponse::_internal_mutable_starttime() {
  
  if (starttime_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    starttime_ = p;
  }
  return starttime_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* addSessionResponse::mutable_starttime() {
  // @@protoc_insertion_point(field_mutable:openoffload.v1alpha2.addSessionResponse.startTime)
  return _internal_mutable_starttime();
}
inline void addSessionResponse::set_allocated_starttime(PROTOBUF_NAMESPACE_ID::Timestamp* starttime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(starttime_);
  }
  if (starttime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(starttime)->GetArena();
    if (message_arena != submessage_arena) {
      starttime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, starttime, submessage_arena);
    }
    
  } else {
    
  }
  starttime_ = starttime;
  // @@protoc_insertion_point(field_set_allocated:openoffload.v1alpha2.addSessionResponse.startTime)
}

// -------------------------------------------------------------------

// sessionResponse

// int64 sessionId = 1;
inline void sessionResponse::clear_sessionid() {
  sessionid_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 sessionResponse::_internal_sessionid() const {
  return sessionid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 sessionResponse::sessionid() const {
  // @@protoc_insertion_point(field_get:openoffload.v1alpha2.sessionResponse.sessionId)
  return _internal_sessionid();
}
inline void sessionResponse::_internal_set_sessionid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  sessionid_ = value;
}
inline void sessionResponse::set_sessionid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_sessionid(value);
  // @@protoc_insertion_point(field_set:openoffload.v1alpha2.sessionResponse.sessionId)
}

// int64 inPackets = 2;
inline void sessionResponse::clear_inpackets() {
  inpackets_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 sessionResponse::_internal_inpackets() const {
  return inpackets_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 sessionResponse::inpackets() const {
  // @@protoc_insertion_point(field_get:openoffload.v1alpha2.sessionResponse.inPackets)
  return _internal_inpackets();
}
inline void sessionResponse::_internal_set_inpackets(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  inpackets_ = value;
}
inline void sessionResponse::set_inpackets(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_inpackets(value);
  // @@protoc_insertion_point(field_set:openoffload.v1alpha2.sessionResponse.inPackets)
}

// int64 outPackets = 3;
inline void sessionResponse::clear_outpackets() {
  outpackets_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 sessionResponse::_internal_outpackets() const {
  return outpackets_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 sessionResponse::outpackets() const {
  // @@protoc_insertion_point(field_get:openoffload.v1alpha2.sessionResponse.outPackets)
  return _internal_outpackets();
}
inline void sessionResponse::_internal_set_outpackets(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  outpackets_ = value;
}
inline void sessionResponse::set_outpackets(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_outpackets(value);
  // @@protoc_insertion_point(field_set:openoffload.v1alpha2.sessionResponse.outPackets)
}

// int64 inBytes = 4;
inline void sessionResponse::clear_inbytes() {
  inbytes_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 sessionResponse::_internal_inbytes() const {
  return inbytes_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 sessionResponse::inbytes() const {
  // @@protoc_insertion_point(field_get:openoffload.v1alpha2.sessionResponse.inBytes)
  return _internal_inbytes();
}
inline void sessionResponse::_internal_set_inbytes(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  inbytes_ = value;
}
inline void sessionResponse::set_inbytes(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_inbytes(value);
  // @@protoc_insertion_point(field_set:openoffload.v1alpha2.sessionResponse.inBytes)
}

// int64 outBytes = 5;
inline void sessionResponse::clear_outbytes() {
  outbytes_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 sessionResponse::_internal_outbytes() const {
  return outbytes_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 sessionResponse::outbytes() const {
  // @@protoc_insertion_point(field_get:openoffload.v1alpha2.sessionResponse.outBytes)
  return _internal_outbytes();
}
inline void sessionResponse::_internal_set_outbytes(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  outbytes_ = value;
}
inline void sessionResponse::set_outbytes(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_outbytes(value);
  // @@protoc_insertion_point(field_set:openoffload.v1alpha2.sessionResponse.outBytes)
}

// .openoffload.v1alpha2.SESSION_STATE sessionState = 6;
inline void sessionResponse::clear_sessionstate() {
  sessionstate_ = 0;
}
inline ::openoffload::v1alpha2::SESSION_STATE sessionResponse::_internal_sessionstate() const {
  return static_cast< ::openoffload::v1alpha2::SESSION_STATE >(sessionstate_);
}
inline ::openoffload::v1alpha2::SESSION_STATE sessionResponse::sessionstate() const {
  // @@protoc_insertion_point(field_get:openoffload.v1alpha2.sessionResponse.sessionState)
  return _internal_sessionstate();
}
inline void sessionResponse::_internal_set_sessionstate(::openoffload::v1alpha2::SESSION_STATE value) {
  
  sessionstate_ = value;
}
inline void sessionResponse::set_sessionstate(::openoffload::v1alpha2::SESSION_STATE value) {
  _internal_set_sessionstate(value);
  // @@protoc_insertion_point(field_set:openoffload.v1alpha2.sessionResponse.sessionState)
}

// .openoffload.v1alpha2.SESSION_CLOSE_CODE sessionCloseCode = 7;
inline void sessionResponse::clear_sessionclosecode() {
  sessionclosecode_ = 0;
}
inline ::openoffload::v1alpha2::SESSION_CLOSE_CODE sessionResponse::_internal_sessionclosecode() const {
  return static_cast< ::openoffload::v1alpha2::SESSION_CLOSE_CODE >(sessionclosecode_);
}
inline ::openoffload::v1alpha2::SESSION_CLOSE_CODE sessionResponse::sessionclosecode() const {
  // @@protoc_insertion_point(field_get:openoffload.v1alpha2.sessionResponse.sessionCloseCode)
  return _internal_sessionclosecode();
}
inline void sessionResponse::_internal_set_sessionclosecode(::openoffload::v1alpha2::SESSION_CLOSE_CODE value) {
  
  sessionclosecode_ = value;
}
inline void sessionResponse::set_sessionclosecode(::openoffload::v1alpha2::SESSION_CLOSE_CODE value) {
  _internal_set_sessionclosecode(value);
  // @@protoc_insertion_point(field_set:openoffload.v1alpha2.sessionResponse.sessionCloseCode)
}

// .openoffload.v1alpha2.REQUEST_STATUS requestStatus = 8;
inline void sessionResponse::clear_requeststatus() {
  requeststatus_ = 0;
}
inline ::openoffload::v1alpha2::REQUEST_STATUS sessionResponse::_internal_requeststatus() const {
  return static_cast< ::openoffload::v1alpha2::REQUEST_STATUS >(requeststatus_);
}
inline ::openoffload::v1alpha2::REQUEST_STATUS sessionResponse::requeststatus() const {
  // @@protoc_insertion_point(field_get:openoffload.v1alpha2.sessionResponse.requestStatus)
  return _internal_requeststatus();
}
inline void sessionResponse::_internal_set_requeststatus(::openoffload::v1alpha2::REQUEST_STATUS value) {
  
  requeststatus_ = value;
}
inline void sessionResponse::set_requeststatus(::openoffload::v1alpha2::REQUEST_STATUS value) {
  _internal_set_requeststatus(value);
  // @@protoc_insertion_point(field_set:openoffload.v1alpha2.sessionResponse.requestStatus)
}

// .google.protobuf.Timestamp startTime = 9;
inline bool sessionResponse::_internal_has_starttime() const {
  return this != internal_default_instance() && starttime_ != nullptr;
}
inline bool sessionResponse::has_starttime() const {
  return _internal_has_starttime();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& sessionResponse::_internal_starttime() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = starttime_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& sessionResponse::starttime() const {
  // @@protoc_insertion_point(field_get:openoffload.v1alpha2.sessionResponse.startTime)
  return _internal_starttime();
}
inline void sessionResponse::unsafe_arena_set_allocated_starttime(
    PROTOBUF_NAMESPACE_ID::Timestamp* starttime) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(starttime_);
  }
  starttime_ = starttime;
  if (starttime) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openoffload.v1alpha2.sessionResponse.startTime)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* sessionResponse::release_starttime() {
  auto temp = unsafe_arena_release_starttime();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* sessionResponse::unsafe_arena_release_starttime() {
  // @@protoc_insertion_point(field_release:openoffload.v1alpha2.sessionResponse.startTime)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = starttime_;
  starttime_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* sessionResponse::_internal_mutable_starttime() {
  
  if (starttime_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    starttime_ = p;
  }
  return starttime_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* sessionResponse::mutable_starttime() {
  // @@protoc_insertion_point(field_mutable:openoffload.v1alpha2.sessionResponse.startTime)
  return _internal_mutable_starttime();
}
inline void sessionResponse::set_allocated_starttime(PROTOBUF_NAMESPACE_ID::Timestamp* starttime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(starttime_);
  }
  if (starttime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(starttime)->GetArena();
    if (message_arena != submessage_arena) {
      starttime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, starttime, submessage_arena);
    }
    
  } else {
    
  }
  starttime_ = starttime;
  // @@protoc_insertion_point(field_set_allocated:openoffload.v1alpha2.sessionResponse.startTime)
}

// .google.protobuf.Timestamp endTime = 10;
inline bool sessionResponse::_internal_has_endtime() const {
  return this != internal_default_instance() && endtime_ != nullptr;
}
inline bool sessionResponse::has_endtime() const {
  return _internal_has_endtime();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& sessionResponse::_internal_endtime() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = endtime_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& sessionResponse::endtime() const {
  // @@protoc_insertion_point(field_get:openoffload.v1alpha2.sessionResponse.endTime)
  return _internal_endtime();
}
inline void sessionResponse::unsafe_arena_set_allocated_endtime(
    PROTOBUF_NAMESPACE_ID::Timestamp* endtime) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endtime_);
  }
  endtime_ = endtime;
  if (endtime) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openoffload.v1alpha2.sessionResponse.endTime)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* sessionResponse::release_endtime() {
  auto temp = unsafe_arena_release_endtime();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* sessionResponse::unsafe_arena_release_endtime() {
  // @@protoc_insertion_point(field_release:openoffload.v1alpha2.sessionResponse.endTime)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = endtime_;
  endtime_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* sessionResponse::_internal_mutable_endtime() {
  
  if (endtime_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    endtime_ = p;
  }
  return endtime_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* sessionResponse::mutable_endtime() {
  // @@protoc_insertion_point(field_mutable:openoffload.v1alpha2.sessionResponse.endTime)
  return _internal_mutable_endtime();
}
inline void sessionResponse::set_allocated_endtime(PROTOBUF_NAMESPACE_ID::Timestamp* endtime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(endtime_);
  }
  if (endtime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endtime)->GetArena();
    if (message_arena != submessage_arena) {
      endtime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endtime, submessage_arena);
    }
    
  } else {
    
  }
  endtime_ = endtime;
  // @@protoc_insertion_point(field_set_allocated:openoffload.v1alpha2.sessionResponse.endTime)
}

// -------------------------------------------------------------------

// statisticsRequestArgs

// int32 pageSize = 1;
inline void statisticsRequestArgs::clear_pagesize() {
  pagesize_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 statisticsRequestArgs::_internal_pagesize() const {
  return pagesize_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 statisticsRequestArgs::pagesize() const {
  // @@protoc_insertion_point(field_get:openoffload.v1alpha2.statisticsRequestArgs.pageSize)
  return _internal_pagesize();
}
inline void statisticsRequestArgs::_internal_set_pagesize(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  pagesize_ = value;
}
inline void statisticsRequestArgs::set_pagesize(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_pagesize(value);
  // @@protoc_insertion_point(field_set:openoffload.v1alpha2.statisticsRequestArgs.pageSize)
}

// -------------------------------------------------------------------

// Empty

// -------------------------------------------------------------------

// deviceDescription

// string name = 1;
inline void deviceDescription::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& deviceDescription::name() const {
  // @@protoc_insertion_point(field_get:openoffload.v1alpha2.deviceDescription.name)
  return _internal_name();
}
inline void deviceDescription::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:openoffload.v1alpha2.deviceDescription.name)
}
inline std::string* deviceDescription::mutable_name() {
  // @@protoc_insertion_point(field_mutable:openoffload.v1alpha2.deviceDescription.name)
  return _internal_mutable_name();
}
inline const std::string& deviceDescription::_internal_name() const {
  return name_.Get();
}
inline void deviceDescription::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void deviceDescription::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:openoffload.v1alpha2.deviceDescription.name)
}
inline void deviceDescription::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:openoffload.v1alpha2.deviceDescription.name)
}
inline void deviceDescription::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:openoffload.v1alpha2.deviceDescription.name)
}
inline std::string* deviceDescription::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* deviceDescription::release_name() {
  // @@protoc_insertion_point(field_release:openoffload.v1alpha2.deviceDescription.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void deviceDescription::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:openoffload.v1alpha2.deviceDescription.name)
}
inline std::string* deviceDescription::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:openoffload.v1alpha2.deviceDescription.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void deviceDescription::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openoffload.v1alpha2.deviceDescription.name)
}

// .openoffload.v1alpha2.INTERFACE_TYPE type = 2;
inline void deviceDescription::clear_type() {
  type_ = 0;
}
inline ::openoffload::v1alpha2::INTERFACE_TYPE deviceDescription::_internal_type() const {
  return static_cast< ::openoffload::v1alpha2::INTERFACE_TYPE >(type_);
}
inline ::openoffload::v1alpha2::INTERFACE_TYPE deviceDescription::type() const {
  // @@protoc_insertion_point(field_get:openoffload.v1alpha2.deviceDescription.type)
  return _internal_type();
}
inline void deviceDescription::_internal_set_type(::openoffload::v1alpha2::INTERFACE_TYPE value) {
  
  type_ = value;
}
inline void deviceDescription::set_type(::openoffload::v1alpha2::INTERFACE_TYPE value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:openoffload.v1alpha2.deviceDescription.type)
}

// string description = 3;
inline void deviceDescription::clear_description() {
  description_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& deviceDescription::description() const {
  // @@protoc_insertion_point(field_get:openoffload.v1alpha2.deviceDescription.description)
  return _internal_description();
}
inline void deviceDescription::set_description(const std::string& value) {
  _internal_set_description(value);
  // @@protoc_insertion_point(field_set:openoffload.v1alpha2.deviceDescription.description)
}
inline std::string* deviceDescription::mutable_description() {
  // @@protoc_insertion_point(field_mutable:openoffload.v1alpha2.deviceDescription.description)
  return _internal_mutable_description();
}
inline const std::string& deviceDescription::_internal_description() const {
  return description_.Get();
}
inline void deviceDescription::_internal_set_description(const std::string& value) {
  
  description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void deviceDescription::set_description(std::string&& value) {
  
  description_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:openoffload.v1alpha2.deviceDescription.description)
}
inline void deviceDescription::set_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:openoffload.v1alpha2.deviceDescription.description)
}
inline void deviceDescription::set_description(const char* value,
    size_t size) {
  
  description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:openoffload.v1alpha2.deviceDescription.description)
}
inline std::string* deviceDescription::_internal_mutable_description() {
  
  return description_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* deviceDescription::release_description() {
  // @@protoc_insertion_point(field_release:openoffload.v1alpha2.deviceDescription.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void deviceDescription::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:openoffload.v1alpha2.deviceDescription.description)
}
inline std::string* deviceDescription::unsafe_arena_release_description() {
  // @@protoc_insertion_point(field_unsafe_arena_release:openoffload.v1alpha2.deviceDescription.description)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return description_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void deviceDescription::unsafe_arena_set_allocated_description(
    std::string* description) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (description != nullptr) {
    
  } else {
    
  }
  description_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      description, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openoffload.v1alpha2.deviceDescription.description)
}

// int32 sessionCapacity = 4;
inline void deviceDescription::clear_sessioncapacity() {
  sessioncapacity_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 deviceDescription::_internal_sessioncapacity() const {
  return sessioncapacity_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 deviceDescription::sessioncapacity() const {
  // @@protoc_insertion_point(field_get:openoffload.v1alpha2.deviceDescription.sessionCapacity)
  return _internal_sessioncapacity();
}
inline void deviceDescription::_internal_set_sessioncapacity(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  sessioncapacity_ = value;
}
inline void deviceDescription::set_sessioncapacity(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_sessioncapacity(value);
  // @@protoc_insertion_point(field_set:openoffload.v1alpha2.deviceDescription.sessionCapacity)
}

// int32 sessionRate = 5;
inline void deviceDescription::clear_sessionrate() {
  sessionrate_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 deviceDescription::_internal_sessionrate() const {
  return sessionrate_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 deviceDescription::sessionrate() const {
  // @@protoc_insertion_point(field_get:openoffload.v1alpha2.deviceDescription.sessionRate)
  return _internal_sessionrate();
}
inline void deviceDescription::_internal_set_sessionrate(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  sessionrate_ = value;
}
inline void deviceDescription::set_sessionrate(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_sessionrate(value);
  // @@protoc_insertion_point(field_set:openoffload.v1alpha2.deviceDescription.sessionRate)
}

// -------------------------------------------------------------------

// deviceList

// repeated .openoffload.v1alpha2.deviceDescription devices = 1;
inline int deviceList::_internal_devices_size() const {
  return devices_.size();
}
inline int deviceList::devices_size() const {
  return _internal_devices_size();
}
inline void deviceList::clear_devices() {
  devices_.Clear();
}
inline ::openoffload::v1alpha2::deviceDescription* deviceList::mutable_devices(int index) {
  // @@protoc_insertion_point(field_mutable:openoffload.v1alpha2.deviceList.devices)
  return devices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openoffload::v1alpha2::deviceDescription >*
deviceList::mutable_devices() {
  // @@protoc_insertion_point(field_mutable_list:openoffload.v1alpha2.deviceList.devices)
  return &devices_;
}
inline const ::openoffload::v1alpha2::deviceDescription& deviceList::_internal_devices(int index) const {
  return devices_.Get(index);
}
inline const ::openoffload::v1alpha2::deviceDescription& deviceList::devices(int index) const {
  // @@protoc_insertion_point(field_get:openoffload.v1alpha2.deviceList.devices)
  return _internal_devices(index);
}
inline ::openoffload::v1alpha2::deviceDescription* deviceList::_internal_add_devices() {
  return devices_.Add();
}
inline ::openoffload::v1alpha2::deviceDescription* deviceList::add_devices() {
  // @@protoc_insertion_point(field_add:openoffload.v1alpha2.deviceList.devices)
  return _internal_add_devices();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::openoffload::v1alpha2::deviceDescription >&
deviceList::devices() const {
  // @@protoc_insertion_point(field_list:openoffload.v1alpha2.deviceList.devices)
  return devices_;
}

// -------------------------------------------------------------------

// registrationStatus

// .openoffload.v1alpha2.REGISTRATION_STATUS_TYPE status = 1;
inline void registrationStatus::clear_status() {
  status_ = 0;
}
inline ::openoffload::v1alpha2::REGISTRATION_STATUS_TYPE registrationStatus::_internal_status() const {
  return static_cast< ::openoffload::v1alpha2::REGISTRATION_STATUS_TYPE >(status_);
}
inline ::openoffload::v1alpha2::REGISTRATION_STATUS_TYPE registrationStatus::status() const {
  // @@protoc_insertion_point(field_get:openoffload.v1alpha2.registrationStatus.status)
  return _internal_status();
}
inline void registrationStatus::_internal_set_status(::openoffload::v1alpha2::REGISTRATION_STATUS_TYPE value) {
  
  status_ = value;
}
inline void registrationStatus::set_status(::openoffload::v1alpha2::REGISTRATION_STATUS_TYPE value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:openoffload.v1alpha2.registrationStatus.status)
}

// -------------------------------------------------------------------

// activationStatus

// .openoffload.v1alpha2.ACTIVATION_STATUS_TYPE status = 1;
inline void activationStatus::clear_status() {
  status_ = 0;
}
inline ::openoffload::v1alpha2::ACTIVATION_STATUS_TYPE activationStatus::_internal_status() const {
  return static_cast< ::openoffload::v1alpha2::ACTIVATION_STATUS_TYPE >(status_);
}
inline ::openoffload::v1alpha2::ACTIVATION_STATUS_TYPE activationStatus::status() const {
  // @@protoc_insertion_point(field_get:openoffload.v1alpha2.activationStatus.status)
  return _internal_status();
}
inline void activationStatus::_internal_set_status(::openoffload::v1alpha2::ACTIVATION_STATUS_TYPE value) {
  
  status_ = value;
}
inline void activationStatus::set_status(::openoffload::v1alpha2::ACTIVATION_STATUS_TYPE value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:openoffload.v1alpha2.activationStatus.status)
}

// .openoffload.v1alpha2.deviceDescription device = 2;
inline bool activationStatus::_internal_has_device() const {
  return this != internal_default_instance() && device_ != nullptr;
}
inline bool activationStatus::has_device() const {
  return _internal_has_device();
}
inline void activationStatus::clear_device() {
  if (GetArena() == nullptr && device_ != nullptr) {
    delete device_;
  }
  device_ = nullptr;
}
inline const ::openoffload::v1alpha2::deviceDescription& activationStatus::_internal_device() const {
  const ::openoffload::v1alpha2::deviceDescription* p = device_;
  return p != nullptr ? *p : *reinterpret_cast<const ::openoffload::v1alpha2::deviceDescription*>(
      &::openoffload::v1alpha2::_deviceDescription_default_instance_);
}
inline const ::openoffload::v1alpha2::deviceDescription& activationStatus::device() const {
  // @@protoc_insertion_point(field_get:openoffload.v1alpha2.activationStatus.device)
  return _internal_device();
}
inline void activationStatus::unsafe_arena_set_allocated_device(
    ::openoffload::v1alpha2::deviceDescription* device) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device_);
  }
  device_ = device;
  if (device) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openoffload.v1alpha2.activationStatus.device)
}
inline ::openoffload::v1alpha2::deviceDescription* activationStatus::release_device() {
  auto temp = unsafe_arena_release_device();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::openoffload::v1alpha2::deviceDescription* activationStatus::unsafe_arena_release_device() {
  // @@protoc_insertion_point(field_release:openoffload.v1alpha2.activationStatus.device)
  
  ::openoffload::v1alpha2::deviceDescription* temp = device_;
  device_ = nullptr;
  return temp;
}
inline ::openoffload::v1alpha2::deviceDescription* activationStatus::_internal_mutable_device() {
  
  if (device_ == nullptr) {
    auto* p = CreateMaybeMessage<::openoffload::v1alpha2::deviceDescription>(GetArena());
    device_ = p;
  }
  return device_;
}
inline ::openoffload::v1alpha2::deviceDescription* activationStatus::mutable_device() {
  // @@protoc_insertion_point(field_mutable:openoffload.v1alpha2.activationStatus.device)
  return _internal_mutable_device();
}
inline void activationStatus::set_allocated_device(::openoffload::v1alpha2::deviceDescription* device) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete device_;
  }
  if (device) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(device);
    if (message_arena != submessage_arena) {
      device = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device, submessage_arena);
    }
    
  } else {
    
  }
  device_ = device;
  // @@protoc_insertion_point(field_set_allocated:openoffload.v1alpha2.activationStatus.device)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1alpha2
}  // namespace openoffload

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::openoffload::v1alpha2::IP_VERSION> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::openoffload::v1alpha2::IP_VERSION>() {
  return ::openoffload::v1alpha2::IP_VERSION_descriptor();
}
template <> struct is_proto_enum< ::openoffload::v1alpha2::PROTOCOL_ID> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::openoffload::v1alpha2::PROTOCOL_ID>() {
  return ::openoffload::v1alpha2::PROTOCOL_ID_descriptor();
}
template <> struct is_proto_enum< ::openoffload::v1alpha2::SESSION_STATE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::openoffload::v1alpha2::SESSION_STATE>() {
  return ::openoffload::v1alpha2::SESSION_STATE_descriptor();
}
template <> struct is_proto_enum< ::openoffload::v1alpha2::SESSION_CLOSE_CODE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::openoffload::v1alpha2::SESSION_CLOSE_CODE>() {
  return ::openoffload::v1alpha2::SESSION_CLOSE_CODE_descriptor();
}
template <> struct is_proto_enum< ::openoffload::v1alpha2::REQUEST_STATUS> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::openoffload::v1alpha2::REQUEST_STATUS>() {
  return ::openoffload::v1alpha2::REQUEST_STATUS_descriptor();
}
template <> struct is_proto_enum< ::openoffload::v1alpha2::ACTION_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::openoffload::v1alpha2::ACTION_TYPE>() {
  return ::openoffload::v1alpha2::ACTION_TYPE_descriptor();
}
template <> struct is_proto_enum< ::openoffload::v1alpha2::INTERFACE_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::openoffload::v1alpha2::INTERFACE_TYPE>() {
  return ::openoffload::v1alpha2::INTERFACE_TYPE_descriptor();
}
template <> struct is_proto_enum< ::openoffload::v1alpha2::ACTIVATION_STATUS_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::openoffload::v1alpha2::ACTIVATION_STATUS_TYPE>() {
  return ::openoffload::v1alpha2::ACTIVATION_STATUS_TYPE_descriptor();
}
template <> struct is_proto_enum< ::openoffload::v1alpha2::REGISTRATION_STATUS_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::openoffload::v1alpha2::REGISTRATION_STATUS_TYPE>() {
  return ::openoffload::v1alpha2::REGISTRATION_STATUS_TYPE_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_openoffload_2eproto
